import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __commonJS
} from "./chunk-ROME4SDB.js";

// node_modules/react-hook-form/dist/index.cjs.js
var require_index_cjs = __commonJS({
  "node_modules/react-hook-form/dist/index.cjs.js"(exports) {
    "use strict";
    function e(e2) {
      return e2 && "object" == typeof e2 && "default" in e2 ? e2 : { default: e2 };
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var t = e(require_react());
    var r = (e2) => "checkbox" === e2.type;
    var s = (e2) => e2 instanceof Date;
    var a = (e2) => null == e2;
    var n = (e2) => "object" == typeof e2;
    var i = (e2) => !a(e2) && !Array.isArray(e2) && n(e2) && !s(e2);
    var u = (e2) => i(e2) && e2.target ? r(e2.target) ? e2.target.checked : e2.target.value : e2;
    var o = (e2, t2) => e2.has(((e3) => e3.substring(0, e3.search(/\.\d+(\.|$)/)) || e3)(t2));
    var l = (e2) => {
      const t2 = e2.constructor && e2.constructor.prototype;
      return i(t2) && t2.hasOwnProperty("isPrototypeOf");
    };
    var d = "undefined" != typeof window && void 0 !== window.HTMLElement && "undefined" != typeof document;
    function c(e2) {
      let t2;
      const r2 = Array.isArray(e2);
      if (e2 instanceof Date)
        t2 = new Date(e2);
      else if (e2 instanceof Set)
        t2 = new Set(e2);
      else {
        if (d && (e2 instanceof Blob || e2 instanceof FileList) || !r2 && !i(e2))
          return e2;
        if (t2 = r2 ? [] : {}, r2 || l(e2))
          for (const r3 in e2)
            e2.hasOwnProperty(r3) && (t2[r3] = c(e2[r3]));
        else
          t2 = e2;
      }
      return t2;
    }
    var f = (e2) => Array.isArray(e2) ? e2.filter(Boolean) : [];
    var m = (e2) => void 0 === e2;
    var y = (e2, t2, r2) => {
      if (!t2 || !i(e2))
        return r2;
      const s2 = f(t2.split(/[,[\].]+?/)).reduce((e3, t3) => a(e3) ? e3 : e3[t3], e2);
      return m(s2) || s2 === e2 ? m(e2[t2]) ? r2 : e2[t2] : s2;
    };
    var p = (e2) => "boolean" == typeof e2;
    var _ = { BLUR: "blur", FOCUS_OUT: "focusout", CHANGE: "change" };
    var h = { onBlur: "onBlur", onChange: "onChange", onSubmit: "onSubmit", onTouched: "onTouched", all: "all" };
    var g = "max";
    var v = "min";
    var b = "maxLength";
    var x = "minLength";
    var A = "pattern";
    var V = "required";
    var F = "validate";
    var S = t.default.createContext(null);
    var w = () => t.default.useContext(S);
    var D = (e2, t2, r2, s2 = true) => {
      const a2 = { defaultValues: t2._defaultValues };
      for (const n2 in e2)
        Object.defineProperty(a2, n2, { get: () => {
          const a3 = n2;
          return t2._proxyFormState[a3] !== h.all && (t2._proxyFormState[a3] = !s2 || h.all), r2 && (r2[a3] = true), e2[a3];
        } });
      return a2;
    };
    var k = (e2) => i(e2) && !Object.keys(e2).length;
    var C = (e2, t2, r2, s2) => {
      r2(e2);
      const { name: a2, ...n2 } = e2;
      return k(n2) || Object.keys(n2).length >= Object.keys(t2).length || Object.keys(n2).find((e3) => t2[e3] === (!s2 || h.all));
    };
    var E = (e2) => Array.isArray(e2) ? e2 : [e2];
    var O = (e2, t2, r2) => !e2 || !t2 || e2 === t2 || E(e2).some((e3) => e3 && (r2 ? e3 === t2 : e3.startsWith(t2) || t2.startsWith(e3)));
    function j(e2) {
      const r2 = t.default.useRef(e2);
      r2.current = e2, t.default.useEffect(() => {
        const t2 = !e2.disabled && r2.current.subject && r2.current.subject.subscribe({ next: r2.current.next });
        return () => {
          t2 && t2.unsubscribe();
        };
      }, [e2.disabled]);
    }
    function T(e2) {
      const r2 = w(), { control: s2 = r2.control, disabled: a2, name: n2, exact: i2 } = e2 || {}, [u2, o2] = t.default.useState(s2._formState), l2 = t.default.useRef(true), d2 = t.default.useRef({ isDirty: false, isLoading: false, dirtyFields: false, touchedFields: false, isValidating: false, isValid: false, errors: false }), c2 = t.default.useRef(n2);
      return c2.current = n2, j({ disabled: a2, next: (e3) => l2.current && O(c2.current, e3.name, i2) && C(e3, d2.current, s2._updateFormState) && o2({ ...s2._formState, ...e3 }), subject: s2._subjects.state }), t.default.useEffect(() => (l2.current = true, d2.current.isValid && s2._updateValid(true), () => {
        l2.current = false;
      }), [s2]), D(u2, s2, d2.current, false);
    }
    var U = (e2) => "string" == typeof e2;
    var B = (e2, t2, r2, s2, a2) => U(e2) ? (s2 && t2.watch.add(e2), y(r2, e2, a2)) : Array.isArray(e2) ? e2.map((e3) => (s2 && t2.watch.add(e3), y(r2, e3))) : (s2 && (t2.watchAll = true), r2);
    function N(e2) {
      const r2 = w(), { control: s2 = r2.control, name: a2, defaultValue: n2, disabled: i2, exact: u2 } = e2 || {}, o2 = t.default.useRef(a2);
      o2.current = a2, j({ disabled: i2, subject: s2._subjects.values, next: (e3) => {
        O(o2.current, e3.name, u2) && d2(c(B(o2.current, s2._names, e3.values || s2._formValues, false, n2)));
      } });
      const [l2, d2] = t.default.useState(s2._getWatch(a2, n2));
      return t.default.useEffect(() => s2._removeUnmounted()), l2;
    }
    var L = (e2) => /^\w*$/.test(e2);
    var M = (e2) => f(e2.replace(/["|']|\]/g, "").split(/\.|\[/));
    function R(e2, t2, r2) {
      let s2 = -1;
      const a2 = L(t2) ? [t2] : M(t2), n2 = a2.length, u2 = n2 - 1;
      for (; ++s2 < n2; ) {
        const t3 = a2[s2];
        let n3 = r2;
        if (s2 !== u2) {
          const r3 = e2[t3];
          n3 = i(r3) || Array.isArray(r3) ? r3 : isNaN(+a2[s2 + 1]) ? {} : [];
        }
        e2[t3] = n3, e2 = e2[t3];
      }
      return e2;
    }
    function P(e2) {
      const r2 = w(), { name: s2, disabled: a2, control: n2 = r2.control, shouldUnregister: i2 } = e2, l2 = o(n2._names.array, s2), d2 = N({ control: n2, name: s2, defaultValue: y(n2._formValues, s2, y(n2._defaultValues, s2, e2.defaultValue)), exact: true }), f2 = T({ control: n2, name: s2 }), h2 = t.default.useRef(n2.register(s2, { ...e2.rules, value: d2 }));
      return h2.current = n2.register(s2, e2.rules), t.default.useEffect(() => {
        const e3 = n2._options.shouldUnregister || i2, t2 = (e4, t3) => {
          const r3 = y(n2._fields, e4);
          r3 && (r3._f.mount = t3);
        };
        if (t2(s2, true), e3) {
          const e4 = c(y(n2._options.defaultValues, s2));
          R(n2._defaultValues, s2, e4), m(y(n2._formValues, s2)) && R(n2._formValues, s2, e4);
        }
        return () => {
          (l2 ? e3 && !n2._state.action : e3) ? n2.unregister(s2) : t2(s2, false);
        };
      }, [s2, n2, l2, i2]), t.default.useEffect(() => {
        y(n2._fields, s2) && n2._updateDisabledField({ disabled: a2, fields: n2._fields, name: s2, value: y(n2._fields, s2)._f.value });
      }, [a2, s2, n2]), { field: { name: s2, value: d2, ...p(a2) || p(f2.disabled) ? { disabled: f2.disabled || a2 } : {}, onChange: t.default.useCallback((e3) => h2.current.onChange({ target: { value: u(e3), name: s2 }, type: _.CHANGE }), [s2]), onBlur: t.default.useCallback(() => h2.current.onBlur({ target: { value: y(n2._formValues, s2), name: s2 }, type: _.BLUR }), [s2, n2]), ref: (e3) => {
        const t2 = y(n2._fields, s2);
        t2 && e3 && (t2._f.ref = { focus: () => e3.focus(), select: () => e3.select(), setCustomValidity: (t3) => e3.setCustomValidity(t3), reportValidity: () => e3.reportValidity() });
      } }, formState: f2, fieldState: Object.defineProperties({}, { invalid: { enumerable: true, get: () => !!y(f2.errors, s2) }, isDirty: { enumerable: true, get: () => !!y(f2.dirtyFields, s2) }, isTouched: { enumerable: true, get: () => !!y(f2.touchedFields, s2) }, error: { enumerable: true, get: () => y(f2.errors, s2) } }) };
    }
    var q = "post";
    var W = (e2, t2, r2, s2, a2) => t2 ? { ...r2[e2], types: { ...r2[e2] && r2[e2].types ? r2[e2].types : {}, [s2]: a2 || true } } : {};
    var I = () => {
      const e2 = "undefined" == typeof performance ? Date.now() : 1e3 * performance.now();
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t2) => {
        const r2 = (16 * Math.random() + e2) % 16 | 0;
        return ("x" == t2 ? r2 : 3 & r2 | 8).toString(16);
      });
    };
    var $ = (e2, t2, r2 = {}) => r2.shouldFocus || m(r2.shouldFocus) ? r2.focusName || `${e2}.${m(r2.focusIndex) ? t2 : r2.focusIndex}.` : "";
    var H = (e2) => ({ isOnSubmit: !e2 || e2 === h.onSubmit, isOnBlur: e2 === h.onBlur, isOnChange: e2 === h.onChange, isOnAll: e2 === h.all, isOnTouch: e2 === h.onTouched });
    var G = (e2, t2, r2) => !r2 && (t2.watchAll || t2.watch.has(e2) || [...t2.watch].some((t3) => e2.startsWith(t3) && /^\.\w+/.test(e2.slice(t3.length))));
    var J = (e2, t2, r2, s2) => {
      for (const a2 of r2 || Object.keys(e2)) {
        const r3 = y(e2, a2);
        if (r3) {
          const { _f: e3, ...n2 } = r3;
          if (e3) {
            if (e3.refs && e3.refs[0] && t2(e3.refs[0], a2) && !s2)
              break;
            if (e3.ref && t2(e3.ref, e3.name) && !s2)
              break;
          } else
            i(n2) && J(n2, t2);
        }
      }
    };
    var z = (e2, t2, r2) => {
      const s2 = f(y(e2, r2));
      return R(s2, "root", t2[r2]), R(e2, r2, s2), e2;
    };
    var K = (e2) => "file" === e2.type;
    var Q = (e2) => "function" == typeof e2;
    var X = (e2) => {
      if (!d)
        return false;
      const t2 = e2 ? e2.ownerDocument : 0;
      return e2 instanceof (t2 && t2.defaultView ? t2.defaultView.HTMLElement : HTMLElement);
    };
    var Y = (e2) => U(e2);
    var Z = (e2) => "radio" === e2.type;
    var ee = (e2) => e2 instanceof RegExp;
    var te = { value: false, isValid: false };
    var re = { value: true, isValid: true };
    var se = (e2) => {
      if (Array.isArray(e2)) {
        if (e2.length > 1) {
          const t2 = e2.filter((e3) => e3 && e3.checked && !e3.disabled).map((e3) => e3.value);
          return { value: t2, isValid: !!t2.length };
        }
        return e2[0].checked && !e2[0].disabled ? e2[0].attributes && !m(e2[0].attributes.value) ? m(e2[0].value) || "" === e2[0].value ? re : { value: e2[0].value, isValid: true } : re : te;
      }
      return te;
    };
    var ae = { isValid: false, value: null };
    var ne = (e2) => Array.isArray(e2) ? e2.reduce((e3, t2) => t2 && t2.checked && !t2.disabled ? { isValid: true, value: t2.value } : e3, ae) : ae;
    function ie(e2, t2, r2 = "validate") {
      if (Y(e2) || Array.isArray(e2) && e2.every(Y) || p(e2) && !e2)
        return { type: r2, message: Y(e2) ? e2 : "", ref: t2 };
    }
    var ue = (e2) => i(e2) && !ee(e2) ? e2 : { value: e2, message: "" };
    var oe = async (e2, t2, s2, n2, u2) => {
      const { ref: o2, refs: l2, required: d2, maxLength: c2, minLength: f2, min: _2, max: h2, pattern: S2, validate: w2, name: D2, valueAsNumber: C2, mount: E2, disabled: O2 } = e2._f, j2 = y(t2, D2);
      if (!E2 || O2)
        return {};
      const T2 = l2 ? l2[0] : o2, B2 = (e3) => {
        n2 && T2.reportValidity && (T2.setCustomValidity(p(e3) ? "" : e3 || ""), T2.reportValidity());
      }, N2 = {}, L2 = Z(o2), M2 = r(o2), R2 = L2 || M2, P2 = (C2 || K(o2)) && m(o2.value) && m(j2) || X(o2) && "" === o2.value || "" === j2 || Array.isArray(j2) && !j2.length, q2 = W.bind(null, D2, s2, N2), I2 = (e3, t3, r2, s3 = b, a2 = x) => {
        const n3 = e3 ? t3 : r2;
        N2[D2] = { type: e3 ? s3 : a2, message: n3, ref: o2, ...q2(e3 ? s3 : a2, n3) };
      };
      if (u2 ? !Array.isArray(j2) || !j2.length : d2 && (!R2 && (P2 || a(j2)) || p(j2) && !j2 || M2 && !se(l2).isValid || L2 && !ne(l2).isValid)) {
        const { value: e3, message: t3 } = Y(d2) ? { value: !!d2, message: d2 } : ue(d2);
        if (e3 && (N2[D2] = { type: V, message: t3, ref: T2, ...q2(V, t3) }, !s2))
          return B2(t3), N2;
      }
      if (!(P2 || a(_2) && a(h2))) {
        let e3, t3;
        const r2 = ue(h2), n3 = ue(_2);
        if (a(j2) || isNaN(j2)) {
          const s3 = o2.valueAsDate || new Date(j2), a2 = (e4) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + e4), i2 = "time" == o2.type, u3 = "week" == o2.type;
          U(r2.value) && j2 && (e3 = i2 ? a2(j2) > a2(r2.value) : u3 ? j2 > r2.value : s3 > new Date(r2.value)), U(n3.value) && j2 && (t3 = i2 ? a2(j2) < a2(n3.value) : u3 ? j2 < n3.value : s3 < new Date(n3.value));
        } else {
          const s3 = o2.valueAsNumber || (j2 ? +j2 : j2);
          a(r2.value) || (e3 = s3 > r2.value), a(n3.value) || (t3 = s3 < n3.value);
        }
        if ((e3 || t3) && (I2(!!e3, r2.message, n3.message, g, v), !s2))
          return B2(N2[D2].message), N2;
      }
      if ((c2 || f2) && !P2 && (U(j2) || u2 && Array.isArray(j2))) {
        const e3 = ue(c2), t3 = ue(f2), r2 = !a(e3.value) && j2.length > +e3.value, n3 = !a(t3.value) && j2.length < +t3.value;
        if ((r2 || n3) && (I2(r2, e3.message, t3.message), !s2))
          return B2(N2[D2].message), N2;
      }
      if (S2 && !P2 && U(j2)) {
        const { value: e3, message: t3 } = ue(S2);
        if (ee(e3) && !j2.match(e3) && (N2[D2] = { type: A, message: t3, ref: o2, ...q2(A, t3) }, !s2))
          return B2(t3), N2;
      }
      if (w2) {
        if (Q(w2)) {
          const e3 = ie(await w2(j2, t2), T2);
          if (e3 && (N2[D2] = { ...e3, ...q2(F, e3.message) }, !s2))
            return B2(e3.message), N2;
        } else if (i(w2)) {
          let e3 = {};
          for (const r2 in w2) {
            if (!k(e3) && !s2)
              break;
            const a2 = ie(await w2[r2](j2, t2), T2, r2);
            a2 && (e3 = { ...a2, ...q2(r2, a2.message) }, B2(a2.message), s2 && (N2[D2] = e3));
          }
          if (!k(e3) && (N2[D2] = { ref: T2, ...e3 }, !s2))
            return N2;
        }
      }
      return B2(true), N2;
    };
    function le(e2, t2) {
      return [...e2, ...E(t2)];
    }
    var de = (e2) => Array.isArray(e2) ? e2.map(() => {
    }) : void 0;
    function ce(e2, t2, r2) {
      return [...e2.slice(0, t2), ...E(r2), ...e2.slice(t2)];
    }
    var fe = (e2, t2, r2) => Array.isArray(e2) ? (m(e2[r2]) && (e2[r2] = void 0), e2.splice(r2, 0, e2.splice(t2, 1)[0]), e2) : [];
    function me(e2, t2) {
      return [...E(t2), ...E(e2)];
    }
    var ye = (e2, t2) => m(t2) ? [] : function(e3, t3) {
      let r2 = 0;
      const s2 = [...e3];
      for (const e4 of t3)
        s2.splice(e4 - r2, 1), r2++;
      return f(s2).length ? s2 : [];
    }(e2, E(t2).sort((e3, t3) => e3 - t3));
    var pe = (e2, t2, r2) => {
      e2[t2] = [e2[r2], e2[r2] = e2[t2]][0];
    };
    function _e(e2, t2) {
      const r2 = Array.isArray(t2) ? t2 : L(t2) ? [t2] : M(t2), s2 = 1 === r2.length ? e2 : function(e3, t3) {
        const r3 = t3.slice(0, -1).length;
        let s3 = 0;
        for (; s3 < r3; )
          e3 = m(e3) ? s3++ : e3[t3[s3++]];
        return e3;
      }(e2, r2), a2 = r2.length - 1, n2 = r2[a2];
      return s2 && delete s2[n2], 0 !== a2 && (i(s2) && k(s2) || Array.isArray(s2) && function(e3) {
        for (const t3 in e3)
          if (e3.hasOwnProperty(t3) && !m(e3[t3]))
            return false;
        return true;
      }(s2)) && _e(e2, r2.slice(0, -1)), e2;
    }
    var he = (e2, t2, r2) => (e2[t2] = r2, e2);
    function ge() {
      let e2 = [];
      return { get observers() {
        return e2;
      }, next: (t2) => {
        for (const r2 of e2)
          r2.next && r2.next(t2);
      }, subscribe: (t2) => (e2.push(t2), { unsubscribe: () => {
        e2 = e2.filter((e3) => e3 !== t2);
      } }), unsubscribe: () => {
        e2 = [];
      } };
    }
    var ve = (e2) => a(e2) || !n(e2);
    function be(e2, t2) {
      if (ve(e2) || ve(t2))
        return e2 === t2;
      if (s(e2) && s(t2))
        return e2.getTime() === t2.getTime();
      const r2 = Object.keys(e2), a2 = Object.keys(t2);
      if (r2.length !== a2.length)
        return false;
      for (const n2 of r2) {
        const r3 = e2[n2];
        if (!a2.includes(n2))
          return false;
        if ("ref" !== n2) {
          const e3 = t2[n2];
          if (s(r3) && s(e3) || i(r3) && i(e3) || Array.isArray(r3) && Array.isArray(e3) ? !be(r3, e3) : r3 !== e3)
            return false;
        }
      }
      return true;
    }
    var xe = (e2) => "select-multiple" === e2.type;
    var Ae = (e2) => Z(e2) || r(e2);
    var Ve = (e2) => X(e2) && e2.isConnected;
    var Fe = (e2) => {
      for (const t2 in e2)
        if (Q(e2[t2]))
          return true;
      return false;
    };
    function Se(e2, t2 = {}) {
      const r2 = Array.isArray(e2);
      if (i(e2) || r2)
        for (const r3 in e2)
          Array.isArray(e2[r3]) || i(e2[r3]) && !Fe(e2[r3]) ? (t2[r3] = Array.isArray(e2[r3]) ? [] : {}, Se(e2[r3], t2[r3])) : a(e2[r3]) || (t2[r3] = true);
      return t2;
    }
    function we(e2, t2, r2) {
      const s2 = Array.isArray(e2);
      if (i(e2) || s2)
        for (const s3 in e2)
          Array.isArray(e2[s3]) || i(e2[s3]) && !Fe(e2[s3]) ? m(t2) || ve(r2[s3]) ? r2[s3] = Array.isArray(e2[s3]) ? Se(e2[s3], []) : { ...Se(e2[s3]) } : we(e2[s3], a(t2) ? {} : t2[s3], r2[s3]) : r2[s3] = !be(e2[s3], t2[s3]);
      return r2;
    }
    var De = (e2, t2) => we(e2, t2, Se(t2));
    var ke = (e2, { valueAsNumber: t2, valueAsDate: r2, setValueAs: s2 }) => m(e2) ? e2 : t2 ? "" === e2 ? NaN : e2 ? +e2 : e2 : r2 && U(e2) ? new Date(e2) : s2 ? s2(e2) : e2;
    function Ce(e2) {
      const t2 = e2.ref;
      if (!(e2.refs ? e2.refs.every((e3) => e3.disabled) : t2.disabled))
        return K(t2) ? t2.files : Z(t2) ? ne(e2.refs).value : xe(t2) ? [...t2.selectedOptions].map(({ value: e3 }) => e3) : r(t2) ? se(e2.refs).value : ke(m(t2.value) ? e2.ref.value : t2.value, e2);
    }
    var Ee = (e2, t2, r2, s2) => {
      const a2 = {};
      for (const r3 of e2) {
        const e3 = y(t2, r3);
        e3 && R(a2, r3, e3._f);
      }
      return { criteriaMode: r2, names: [...e2], fields: a2, shouldUseNativeValidation: s2 };
    };
    var Oe = (e2) => m(e2) ? e2 : ee(e2) ? e2.source : i(e2) ? ee(e2.value) ? e2.value.source : e2.value : e2;
    var je = (e2) => e2.mount && (e2.required || e2.min || e2.max || e2.maxLength || e2.minLength || e2.pattern || e2.validate);
    function Te(e2, t2, r2) {
      const s2 = y(e2, r2);
      if (s2 || L(r2))
        return { error: s2, name: r2 };
      const a2 = r2.split(".");
      for (; a2.length; ) {
        const s3 = a2.join("."), n2 = y(t2, s3), i2 = y(e2, s3);
        if (n2 && !Array.isArray(n2) && r2 !== s3)
          return { name: r2 };
        if (i2 && i2.type)
          return { name: s3, error: i2 };
        a2.pop();
      }
      return { name: r2 };
    }
    var Ue = (e2, t2, r2, s2, a2) => !a2.isOnAll && (!r2 && a2.isOnTouch ? !(t2 || e2) : (r2 ? s2.isOnBlur : a2.isOnBlur) ? !e2 : !(r2 ? s2.isOnChange : a2.isOnChange) || e2);
    var Be = (e2, t2) => !f(y(e2, t2)).length && _e(e2, t2);
    var Ne = { mode: h.onSubmit, reValidateMode: h.onChange, shouldFocusError: true };
    function Le(e2 = {}, t2) {
      let n2, l2 = { ...Ne, ...e2 }, g2 = { submitCount: 0, isDirty: false, isLoading: Q(l2.defaultValues), isValidating: false, isSubmitted: false, isSubmitting: false, isSubmitSuccessful: false, isValid: false, touchedFields: {}, dirtyFields: {}, errors: {}, disabled: false }, v2 = {}, b2 = (i(l2.defaultValues) || i(l2.values)) && c(l2.defaultValues || l2.values) || {}, x2 = l2.shouldUnregister ? {} : c(b2), A2 = { action: false, mount: false, watch: false }, V2 = { mount: /* @__PURE__ */ new Set(), unMount: /* @__PURE__ */ new Set(), array: /* @__PURE__ */ new Set(), watch: /* @__PURE__ */ new Set() }, F2 = 0;
      const S2 = { isDirty: false, dirtyFields: false, touchedFields: false, isValidating: false, isValid: false, errors: false }, w2 = { values: ge(), array: ge(), state: ge() }, D2 = e2.resetOptions && e2.resetOptions.keepDirtyValues, C2 = H(l2.mode), O2 = H(l2.reValidateMode), j2 = l2.criteriaMode === h.all, T2 = async (e3) => {
        if (S2.isValid || e3) {
          const e4 = l2.resolver ? k((await q2()).errors) : await W2(v2, true);
          e4 !== g2.isValid && w2.state.next({ isValid: e4 });
        }
      }, N2 = (e3) => S2.isValidating && w2.state.next({ isValidating: e3 }), L2 = (e3, t3, r2, s2) => {
        const a2 = y(v2, e3);
        if (a2) {
          const n3 = y(x2, e3, m(r2) ? y(b2, e3) : r2);
          m(n3) || s2 && s2.defaultChecked || t3 ? R(x2, e3, t3 ? n3 : Ce(a2._f)) : Y2(e3, n3), A2.mount && T2();
        }
      }, M2 = (e3, t3, r2, s2, a2) => {
        let n3 = false, i2 = false;
        const u2 = { name: e3 };
        if (!r2 || s2) {
          S2.isDirty && (i2 = g2.isDirty, g2.isDirty = u2.isDirty = I2(), n3 = i2 !== u2.isDirty);
          const r3 = be(y(b2, e3), t3);
          i2 = y(g2.dirtyFields, e3), r3 ? _e(g2.dirtyFields, e3) : R(g2.dirtyFields, e3, true), u2.dirtyFields = g2.dirtyFields, n3 = n3 || S2.dirtyFields && i2 !== !r3;
        }
        if (r2) {
          const t4 = y(g2.touchedFields, e3);
          t4 || (R(g2.touchedFields, e3, r2), u2.touchedFields = g2.touchedFields, n3 = n3 || S2.touchedFields && t4 !== r2);
        }
        return n3 && a2 && w2.state.next(u2), n3 ? u2 : {};
      }, P2 = (t3, r2, s2, a2) => {
        const i2 = y(g2.errors, t3), u2 = S2.isValid && p(r2) && g2.isValid !== r2;
        var o2;
        if (e2.delayError && s2 ? (o2 = () => ((e3, t4) => {
          R(g2.errors, e3, t4), w2.state.next({ errors: g2.errors });
        })(t3, s2), n2 = (e3) => {
          clearTimeout(F2), F2 = setTimeout(o2, e3);
        }, n2(e2.delayError)) : (clearTimeout(F2), n2 = null, s2 ? R(g2.errors, t3, s2) : _e(g2.errors, t3)), (s2 ? !be(i2, s2) : i2) || !k(a2) || u2) {
          const e3 = { ...a2, ...u2 && p(r2) ? { isValid: r2 } : {}, errors: g2.errors, name: t3 };
          g2 = { ...g2, ...e3 }, w2.state.next(e3);
        }
        N2(false);
      }, q2 = async (e3) => l2.resolver(x2, l2.context, Ee(e3 || V2.mount, v2, l2.criteriaMode, l2.shouldUseNativeValidation)), W2 = async (e3, t3, r2 = { valid: true }) => {
        for (const s2 in e3) {
          const a2 = e3[s2];
          if (a2) {
            const { _f: e4, ...s3 } = a2;
            if (e4) {
              const s4 = V2.array.has(e4.name), n3 = await oe(a2, x2, j2, l2.shouldUseNativeValidation && !t3, s4);
              if (n3[e4.name] && (r2.valid = false, t3))
                break;
              !t3 && (y(n3, e4.name) ? s4 ? z(g2.errors, n3, e4.name) : R(g2.errors, e4.name, n3[e4.name]) : _e(g2.errors, e4.name));
            }
            s3 && await W2(s3, t3, r2);
          }
        }
        return r2.valid;
      }, I2 = (e3, t3) => (e3 && t3 && R(x2, e3, t3), !be(ae2(), b2)), $2 = (e3, t3, r2) => B(e3, V2, { ...A2.mount ? x2 : m(t3) ? b2 : U(e3) ? { [e3]: t3 } : t3 }, r2, t3), Y2 = (e3, t3, s2 = {}) => {
        const n3 = y(v2, e3);
        let i2 = t3;
        if (n3) {
          const s3 = n3._f;
          s3 && (!s3.disabled && R(x2, e3, ke(t3, s3)), i2 = X(s3.ref) && a(t3) ? "" : t3, xe(s3.ref) ? [...s3.ref.options].forEach((e4) => e4.selected = i2.includes(e4.value)) : s3.refs ? r(s3.ref) ? s3.refs.length > 1 ? s3.refs.forEach((e4) => (!e4.defaultChecked || !e4.disabled) && (e4.checked = Array.isArray(i2) ? !!i2.find((t4) => t4 === e4.value) : i2 === e4.value)) : s3.refs[0] && (s3.refs[0].checked = !!i2) : s3.refs.forEach((e4) => e4.checked = e4.value === i2) : K(s3.ref) ? s3.ref.value = "" : (s3.ref.value = i2, s3.ref.type || w2.values.next({ name: e3, values: { ...x2 } })));
        }
        (s2.shouldDirty || s2.shouldTouch) && M2(e3, i2, s2.shouldTouch, s2.shouldDirty, true), s2.shouldValidate && se2(e3);
      }, Z2 = (e3, t3, r2) => {
        for (const a2 in t3) {
          const n3 = t3[a2], i2 = `${e3}.${a2}`, u2 = y(v2, i2);
          !V2.array.has(e3) && ve(n3) && (!u2 || u2._f) || s(n3) ? Y2(i2, n3, r2) : Z2(i2, n3, r2);
        }
      }, ee2 = (e3, r2, s2 = {}) => {
        const n3 = y(v2, e3), i2 = V2.array.has(e3), u2 = c(r2);
        R(x2, e3, u2), i2 ? (w2.array.next({ name: e3, values: { ...x2 } }), (S2.isDirty || S2.dirtyFields) && s2.shouldDirty && w2.state.next({ name: e3, dirtyFields: De(b2, x2), isDirty: I2(e3, u2) })) : !n3 || n3._f || a(u2) ? Y2(e3, u2, s2) : Z2(e3, u2, s2), G(e3, V2) && w2.state.next({ ...g2 }), w2.values.next({ name: e3, values: { ...x2 } }), !A2.mount && t2();
      }, te2 = async (e3) => {
        const t3 = e3.target;
        let r2 = t3.name, s2 = true;
        const a2 = y(v2, r2), i2 = (e4) => {
          s2 = Number.isNaN(e4) || e4 === y(x2, r2, e4);
        };
        if (a2) {
          let o2, d2;
          const c2 = t3.type ? Ce(a2._f) : u(e3), f2 = e3.type === _.BLUR || e3.type === _.FOCUS_OUT, m2 = !je(a2._f) && !l2.resolver && !y(g2.errors, r2) && !a2._f.deps || Ue(f2, y(g2.touchedFields, r2), g2.isSubmitted, O2, C2), p2 = G(r2, V2, f2);
          R(x2, r2, c2), f2 ? (a2._f.onBlur && a2._f.onBlur(e3), n2 && n2(0)) : a2._f.onChange && a2._f.onChange(e3);
          const h2 = M2(r2, c2, f2, false), b3 = !k(h2) || p2;
          if (!f2 && w2.values.next({ name: r2, type: e3.type, values: { ...x2 } }), m2)
            return S2.isValid && T2(), b3 && w2.state.next({ name: r2, ...p2 ? {} : h2 });
          if (!f2 && p2 && w2.state.next({ ...g2 }), N2(true), l2.resolver) {
            const { errors: e4 } = await q2([r2]);
            if (i2(c2), s2) {
              const t4 = Te(g2.errors, v2, r2), s3 = Te(e4, v2, t4.name || r2);
              o2 = s3.error, r2 = s3.name, d2 = k(e4);
            }
          } else
            o2 = (await oe(a2, x2, j2, l2.shouldUseNativeValidation))[r2], i2(c2), s2 && (o2 ? d2 = false : S2.isValid && (d2 = await W2(v2, true)));
          s2 && (a2._f.deps && se2(a2._f.deps), P2(r2, d2, o2, h2));
        }
      }, re2 = (e3, t3) => {
        if (y(g2.errors, t3) && e3.focus)
          return e3.focus(), 1;
      }, se2 = async (e3, t3 = {}) => {
        let r2, s2;
        const a2 = E(e3);
        if (N2(true), l2.resolver) {
          const t4 = await (async (e4) => {
            const { errors: t5 } = await q2(e4);
            if (e4)
              for (const r3 of e4) {
                const e5 = y(t5, r3);
                e5 ? R(g2.errors, r3, e5) : _e(g2.errors, r3);
              }
            else
              g2.errors = t5;
            return t5;
          })(m(e3) ? e3 : a2);
          r2 = k(t4), s2 = e3 ? !a2.some((e4) => y(t4, e4)) : r2;
        } else
          e3 ? (s2 = (await Promise.all(a2.map(async (e4) => {
            const t4 = y(v2, e4);
            return await W2(t4 && t4._f ? { [e4]: t4 } : t4);
          }))).every(Boolean), (s2 || g2.isValid) && T2()) : s2 = r2 = await W2(v2);
        return w2.state.next({ ...!U(e3) || S2.isValid && r2 !== g2.isValid ? {} : { name: e3 }, ...l2.resolver || !e3 ? { isValid: r2 } : {}, errors: g2.errors, isValidating: false }), t3.shouldFocus && !s2 && J(v2, re2, e3 ? a2 : V2.mount), s2;
      }, ae2 = (e3) => {
        const t3 = { ...b2, ...A2.mount ? x2 : {} };
        return m(e3) ? t3 : U(e3) ? y(t3, e3) : e3.map((e4) => y(t3, e4));
      }, ne2 = (e3, t3) => ({ invalid: !!y((t3 || g2).errors, e3), isDirty: !!y((t3 || g2).dirtyFields, e3), isTouched: !!y((t3 || g2).touchedFields, e3), error: y((t3 || g2).errors, e3) }), ie2 = (e3, t3, r2) => {
        const s2 = (y(v2, e3, { _f: {} })._f || {}).ref;
        R(g2.errors, e3, { ...t3, ref: s2 }), w2.state.next({ name: e3, errors: g2.errors, isValid: false }), r2 && r2.shouldFocus && s2 && s2.focus && s2.focus();
      }, ue2 = (e3, t3 = {}) => {
        for (const r2 of e3 ? E(e3) : V2.mount)
          V2.mount.delete(r2), V2.array.delete(r2), t3.keepValue || (_e(v2, r2), _e(x2, r2)), !t3.keepError && _e(g2.errors, r2), !t3.keepDirty && _e(g2.dirtyFields, r2), !t3.keepTouched && _e(g2.touchedFields, r2), !l2.shouldUnregister && !t3.keepDefaultValue && _e(b2, r2);
        w2.values.next({ values: { ...x2 } }), w2.state.next({ ...g2, ...t3.keepDirty ? { isDirty: I2() } : {} }), !t3.keepIsValid && T2();
      }, le2 = ({ disabled: e3, name: t3, field: r2, fields: s2, value: a2 }) => {
        if (p(e3)) {
          const n3 = e3 ? void 0 : m(a2) ? Ce(r2 ? r2._f : y(s2, t3)._f) : a2;
          R(x2, t3, n3), M2(t3, n3, false, false, true);
        }
      }, de2 = (e3, t3 = {}) => {
        let r2 = y(v2, e3);
        const s2 = p(t3.disabled);
        return R(v2, e3, { ...r2 || {}, _f: { ...r2 && r2._f ? r2._f : { ref: { name: e3 } }, name: e3, mount: true, ...t3 } }), V2.mount.add(e3), r2 ? le2({ field: r2, disabled: t3.disabled, name: e3 }) : L2(e3, true, t3.value), { ...s2 ? { disabled: t3.disabled } : {}, ...l2.progressive ? { required: !!t3.required, min: Oe(t3.min), max: Oe(t3.max), minLength: Oe(t3.minLength), maxLength: Oe(t3.maxLength), pattern: Oe(t3.pattern) } : {}, name: e3, onChange: te2, onBlur: te2, ref: (s3) => {
          if (s3) {
            de2(e3, t3), r2 = y(v2, e3);
            const a2 = m(s3.value) && s3.querySelectorAll && s3.querySelectorAll("input,select,textarea")[0] || s3, n3 = Ae(a2), i2 = r2._f.refs || [];
            if (n3 ? i2.find((e4) => e4 === a2) : a2 === r2._f.ref)
              return;
            R(v2, e3, { _f: { ...r2._f, ...n3 ? { refs: [...i2.filter(Ve), a2, ...Array.isArray(y(b2, e3)) ? [{}] : []], ref: { type: a2.type, name: e3 } } : { ref: a2 } } }), L2(e3, false, void 0, a2);
          } else
            r2 = y(v2, e3, {}), r2._f && (r2._f.mount = false), (l2.shouldUnregister || t3.shouldUnregister) && (!o(V2.array, e3) || !A2.action) && V2.unMount.add(e3);
        } };
      }, ce2 = () => l2.shouldFocusError && J(v2, re2, V2.mount), fe2 = (e3, t3) => async (r2) => {
        r2 && (r2.preventDefault && r2.preventDefault(), r2.persist && r2.persist());
        let s2 = c(x2);
        if (w2.state.next({ isSubmitting: true }), l2.resolver) {
          const { errors: e4, values: t4 } = await q2();
          g2.errors = e4, s2 = t4;
        } else
          await W2(v2);
        _e(g2.errors, "root"), k(g2.errors) ? (w2.state.next({ errors: {} }), await e3(s2, r2)) : (t3 && await t3({ ...g2.errors }, r2), ce2(), setTimeout(ce2)), w2.state.next({ isSubmitted: true, isSubmitting: false, isSubmitSuccessful: k(g2.errors), submitCount: g2.submitCount + 1, errors: g2.errors });
      }, me2 = (r2, s2 = {}) => {
        const a2 = r2 ? c(r2) : b2, n3 = c(a2), i2 = r2 && !k(r2) ? n3 : b2;
        if (s2.keepDefaultValues || (b2 = a2), !s2.keepValues) {
          if (s2.keepDirtyValues || D2)
            for (const e3 of V2.mount)
              y(g2.dirtyFields, e3) ? R(i2, e3, y(x2, e3)) : ee2(e3, y(i2, e3));
          else {
            if (d && m(r2))
              for (const e3 of V2.mount) {
                const t3 = y(v2, e3);
                if (t3 && t3._f) {
                  const e4 = Array.isArray(t3._f.refs) ? t3._f.refs[0] : t3._f.ref;
                  if (X(e4)) {
                    const t4 = e4.closest("form");
                    if (t4) {
                      t4.reset();
                      break;
                    }
                  }
                }
              }
            v2 = {};
          }
          x2 = e2.shouldUnregister ? s2.keepDefaultValues ? c(b2) : {} : c(i2), w2.array.next({ values: { ...i2 } }), w2.values.next({ values: { ...i2 } });
        }
        V2 = { mount: /* @__PURE__ */ new Set(), unMount: /* @__PURE__ */ new Set(), array: /* @__PURE__ */ new Set(), watch: /* @__PURE__ */ new Set(), watchAll: false, focus: "" }, !A2.mount && t2(), A2.mount = !S2.isValid || !!s2.keepIsValid, A2.watch = !!e2.shouldUnregister, w2.state.next({ submitCount: s2.keepSubmitCount ? g2.submitCount : 0, isDirty: s2.keepDirty ? g2.isDirty : !(!s2.keepDefaultValues || be(r2, b2)), isSubmitted: !!s2.keepIsSubmitted && g2.isSubmitted, dirtyFields: s2.keepDirtyValues ? g2.dirtyFields : s2.keepDefaultValues && r2 ? De(b2, r2) : {}, touchedFields: s2.keepTouched ? g2.touchedFields : {}, errors: s2.keepErrors ? g2.errors : {}, isSubmitSuccessful: !!s2.keepIsSubmitSuccessful && g2.isSubmitSuccessful, isSubmitting: false });
      }, ye2 = (e3, t3) => me2(Q(e3) ? e3(x2) : e3, t3);
      return { control: { register: de2, unregister: ue2, getFieldState: ne2, handleSubmit: fe2, setError: ie2, _executeSchema: q2, _getWatch: $2, _getDirty: I2, _updateValid: T2, _removeUnmounted: () => {
        for (const e3 of V2.unMount) {
          const t3 = y(v2, e3);
          t3 && (t3._f.refs ? t3._f.refs.every((e4) => !Ve(e4)) : !Ve(t3._f.ref)) && ue2(e3);
        }
        V2.unMount = /* @__PURE__ */ new Set();
      }, _updateFieldArray: (e3, t3 = [], r2, s2, a2 = true, n3 = true) => {
        if (s2 && r2) {
          if (A2.action = true, n3 && Array.isArray(y(v2, e3))) {
            const t4 = r2(y(v2, e3), s2.argA, s2.argB);
            a2 && R(v2, e3, t4);
          }
          if (n3 && Array.isArray(y(g2.errors, e3))) {
            const t4 = r2(y(g2.errors, e3), s2.argA, s2.argB);
            a2 && R(g2.errors, e3, t4), Be(g2.errors, e3);
          }
          if (S2.touchedFields && n3 && Array.isArray(y(g2.touchedFields, e3))) {
            const t4 = r2(y(g2.touchedFields, e3), s2.argA, s2.argB);
            a2 && R(g2.touchedFields, e3, t4);
          }
          S2.dirtyFields && (g2.dirtyFields = De(b2, x2)), w2.state.next({ name: e3, isDirty: I2(e3, t3), dirtyFields: g2.dirtyFields, errors: g2.errors, isValid: g2.isValid });
        } else
          R(x2, e3, t3);
      }, _updateDisabledField: le2, _getFieldArray: (t3) => f(y(A2.mount ? x2 : b2, t3, e2.shouldUnregister ? y(b2, t3, []) : [])), _reset: me2, _resetDefaultValues: () => Q(l2.defaultValues) && l2.defaultValues().then((e3) => {
        ye2(e3, l2.resetOptions), w2.state.next({ isLoading: false });
      }), _updateFormState: (e3) => {
        g2 = { ...g2, ...e3 };
      }, _disableForm: (e3) => {
        p(e3) && (w2.state.next({ disabled: e3 }), J(v2, (t3) => {
          t3.disabled = e3;
        }, 0, false));
      }, _subjects: w2, _proxyFormState: S2, get _fields() {
        return v2;
      }, get _formValues() {
        return x2;
      }, get _state() {
        return A2;
      }, set _state(e3) {
        A2 = e3;
      }, get _defaultValues() {
        return b2;
      }, get _names() {
        return V2;
      }, set _names(e3) {
        V2 = e3;
      }, get _formState() {
        return g2;
      }, set _formState(e3) {
        g2 = e3;
      }, get _options() {
        return l2;
      }, set _options(e3) {
        l2 = { ...l2, ...e3 };
      } }, trigger: se2, register: de2, handleSubmit: fe2, watch: (e3, t3) => Q(e3) ? w2.values.subscribe({ next: (r2) => e3($2(void 0, t3), r2) }) : $2(e3, t3, true), setValue: ee2, getValues: ae2, reset: ye2, resetField: (e3, t3 = {}) => {
        y(v2, e3) && (m(t3.defaultValue) ? ee2(e3, y(b2, e3)) : (ee2(e3, t3.defaultValue), R(b2, e3, t3.defaultValue)), t3.keepTouched || _e(g2.touchedFields, e3), t3.keepDirty || (_e(g2.dirtyFields, e3), g2.isDirty = t3.defaultValue ? I2(e3, y(b2, e3)) : I2()), t3.keepError || (_e(g2.errors, e3), S2.isValid && T2()), w2.state.next({ ...g2 }));
      }, clearErrors: (e3) => {
        e3 && E(e3).forEach((e4) => _e(g2.errors, e4)), w2.state.next({ errors: e3 ? g2.errors : {} });
      }, unregister: ue2, setError: ie2, setFocus: (e3, t3 = {}) => {
        const r2 = y(v2, e3), s2 = r2 && r2._f;
        if (s2) {
          const e4 = s2.refs ? s2.refs[0] : s2.ref;
          e4.focus && (e4.focus(), t3.shouldSelect && e4.select());
        }
      }, getFieldState: ne2 };
    }
    exports.Controller = (e2) => e2.render(P(e2)), exports.Form = function(e2) {
      const r2 = w(), [s2, a2] = t.default.useState(false), { control: n2 = r2.control, onSubmit: i2, children: u2, action: o2, method: l2 = q, headers: d2, encType: c2, onError: f2, render: m2, onSuccess: p2, validateStatus: _2, ...h2 } = e2, g2 = async (t2) => {
        let r3 = false, s3 = "";
        await n2.handleSubmit(async (e3) => {
          const a3 = new FormData();
          let u3 = "";
          try {
            u3 = JSON.stringify(e3);
          } catch (e4) {
          }
          for (const t3 of n2._names.mount)
            a3.append(t3, y(e3, t3));
          if (i2 && await i2({ data: e3, event: t2, method: l2, formData: a3, formDataJson: u3 }), o2)
            try {
              const e4 = [d2 && d2["Content-Type"], c2].some((e5) => e5 && e5.includes("json")), t3 = await fetch(o2, { method: l2, headers: { ...d2, ...c2 ? { "Content-Type": c2 } : {} }, body: e4 ? u3 : a3 });
              t3 && (_2 ? !_2(t3.status) : t3.status < 200 || t3.status >= 300) ? (r3 = true, f2 && f2({ response: t3 }), s3 = String(t3.status)) : p2 && p2({ response: t3 });
            } catch (e4) {
              r3 = true, f2 && f2({ error: e4 });
            }
        })(t2), r3 && e2.control && (e2.control._subjects.state.next({ isSubmitSuccessful: false }), e2.control.setError("root.server", { type: s3 }));
      };
      return t.default.useEffect(() => {
        a2(true);
      }, []), m2 ? t.default.createElement(t.default.Fragment, null, m2({ submit: g2 })) : t.default.createElement("form", { noValidate: s2, action: o2, method: l2, encType: c2, onSubmit: g2, ...h2 }, u2);
    }, exports.FormProvider = (e2) => {
      const { children: r2, ...s2 } = e2;
      return t.default.createElement(S.Provider, { value: s2 }, r2);
    }, exports.appendErrors = W, exports.get = y, exports.set = R, exports.useController = P, exports.useFieldArray = function(e2) {
      const r2 = w(), { control: s2 = r2.control, name: a2, keyName: n2 = "id", shouldUnregister: i2 } = e2, [u2, o2] = t.default.useState(s2._getFieldArray(a2)), l2 = t.default.useRef(s2._getFieldArray(a2).map(I)), d2 = t.default.useRef(u2), f2 = t.default.useRef(a2), m2 = t.default.useRef(false);
      f2.current = a2, d2.current = u2, s2._names.array.add(a2), e2.rules && s2.register(a2, e2.rules), j({ next: ({ values: e3, name: t2 }) => {
        if (t2 === f2.current || !t2) {
          const t3 = y(e3, f2.current);
          Array.isArray(t3) && (o2(t3), l2.current = t3.map(I));
        }
      }, subject: s2._subjects.array });
      const p2 = t.default.useCallback((e3) => {
        m2.current = true, s2._updateFieldArray(a2, e3);
      }, [s2, a2]);
      return t.default.useEffect(() => {
        if (s2._state.action = false, G(a2, s2._names) && s2._subjects.state.next({ ...s2._formState }), m2.current && (!H(s2._options.mode).isOnSubmit || s2._formState.isSubmitted))
          if (s2._options.resolver)
            s2._executeSchema([a2]).then((e3) => {
              const t2 = y(e3.errors, a2), r3 = y(s2._formState.errors, a2);
              (r3 ? !t2 && r3.type || t2 && (r3.type !== t2.type || r3.message !== t2.message) : t2 && t2.type) && (t2 ? R(s2._formState.errors, a2, t2) : _e(s2._formState.errors, a2), s2._subjects.state.next({ errors: s2._formState.errors }));
            });
          else {
            const e3 = y(s2._fields, a2);
            e3 && e3._f && oe(e3, s2._formValues, s2._options.criteriaMode === h.all, s2._options.shouldUseNativeValidation, true).then((e4) => !k(e4) && s2._subjects.state.next({ errors: z(s2._formState.errors, e4, a2) }));
          }
        s2._subjects.values.next({ name: a2, values: { ...s2._formValues } }), s2._names.focus && J(s2._fields, (e3, t2) => {
          if (s2._names.focus && t2.startsWith(s2._names.focus) && e3.focus)
            return e3.focus(), 1;
        }), s2._names.focus = "", s2._updateValid(), m2.current = false;
      }, [u2, a2, s2]), t.default.useEffect(() => (!y(s2._formValues, a2) && s2._updateFieldArray(a2), () => {
        (s2._options.shouldUnregister || i2) && s2.unregister(a2);
      }), [a2, s2, n2, i2]), { swap: t.default.useCallback((e3, t2) => {
        const r3 = s2._getFieldArray(a2);
        pe(r3, e3, t2), pe(l2.current, e3, t2), p2(r3), o2(r3), s2._updateFieldArray(a2, r3, pe, { argA: e3, argB: t2 }, false);
      }, [p2, a2, s2]), move: t.default.useCallback((e3, t2) => {
        const r3 = s2._getFieldArray(a2);
        fe(r3, e3, t2), fe(l2.current, e3, t2), p2(r3), o2(r3), s2._updateFieldArray(a2, r3, fe, { argA: e3, argB: t2 }, false);
      }, [p2, a2, s2]), prepend: t.default.useCallback((e3, t2) => {
        const r3 = E(c(e3)), n3 = me(s2._getFieldArray(a2), r3);
        s2._names.focus = $(a2, 0, t2), l2.current = me(l2.current, r3.map(I)), p2(n3), o2(n3), s2._updateFieldArray(a2, n3, me, { argA: de(e3) });
      }, [p2, a2, s2]), append: t.default.useCallback((e3, t2) => {
        const r3 = E(c(e3)), n3 = le(s2._getFieldArray(a2), r3);
        s2._names.focus = $(a2, n3.length - 1, t2), l2.current = le(l2.current, r3.map(I)), p2(n3), o2(n3), s2._updateFieldArray(a2, n3, le, { argA: de(e3) });
      }, [p2, a2, s2]), remove: t.default.useCallback((e3) => {
        const t2 = ye(s2._getFieldArray(a2), e3);
        l2.current = ye(l2.current, e3), p2(t2), o2(t2), s2._updateFieldArray(a2, t2, ye, { argA: e3 });
      }, [p2, a2, s2]), insert: t.default.useCallback((e3, t2, r3) => {
        const n3 = E(c(t2)), i3 = ce(s2._getFieldArray(a2), e3, n3);
        s2._names.focus = $(a2, e3, r3), l2.current = ce(l2.current, e3, n3.map(I)), p2(i3), o2(i3), s2._updateFieldArray(a2, i3, ce, { argA: e3, argB: de(t2) });
      }, [p2, a2, s2]), update: t.default.useCallback((e3, t2) => {
        const r3 = c(t2), n3 = he(s2._getFieldArray(a2), e3, r3);
        l2.current = [...n3].map((t3, r4) => t3 && r4 !== e3 ? l2.current[r4] : I()), p2(n3), o2([...n3]), s2._updateFieldArray(a2, n3, he, { argA: e3, argB: r3 }, true, false);
      }, [p2, a2, s2]), replace: t.default.useCallback((e3) => {
        const t2 = E(c(e3));
        l2.current = t2.map(I), p2([...t2]), o2([...t2]), s2._updateFieldArray(a2, [...t2], (e4) => e4, {}, true, false);
      }, [p2, a2, s2]), fields: t.default.useMemo(() => u2.map((e3, t2) => ({ ...e3, [n2]: l2.current[t2] || I() })), [u2, n2]) };
    }, exports.useForm = function(e2 = {}) {
      const r2 = t.default.useRef(), s2 = t.default.useRef(), [a2, n2] = t.default.useState({ isDirty: false, isValidating: false, isLoading: Q(e2.defaultValues), isSubmitted: false, isSubmitting: false, isSubmitSuccessful: false, isValid: false, submitCount: 0, dirtyFields: {}, touchedFields: {}, errors: {}, disabled: false, defaultValues: Q(e2.defaultValues) ? void 0 : e2.defaultValues });
      r2.current || (r2.current = { ...Le(e2, () => n2((e3) => ({ ...e3 }))), formState: a2 });
      const i2 = r2.current.control;
      return i2._options = e2, j({ subject: i2._subjects.state, next: (e3) => {
        C(e3, i2._proxyFormState, i2._updateFormState, true) && n2({ ...i2._formState });
      } }), t.default.useEffect(() => i2._disableForm(e2.disabled), [i2, e2.disabled]), t.default.useEffect(() => {
        if (i2._proxyFormState.isDirty) {
          const e3 = i2._getDirty();
          e3 !== a2.isDirty && i2._subjects.state.next({ isDirty: e3 });
        }
      }, [i2, a2.isDirty]), t.default.useEffect(() => {
        e2.values && !be(e2.values, s2.current) ? (i2._reset(e2.values, i2._options.resetOptions), s2.current = e2.values) : i2._resetDefaultValues();
      }, [e2.values, i2]), t.default.useEffect(() => {
        i2._state.mount || (i2._updateValid(), i2._state.mount = true), i2._state.watch && (i2._state.watch = false, i2._subjects.state.next({ ...i2._formState })), i2._removeUnmounted();
      }), r2.current.formState = D(a2, i2), r2.current;
    }, exports.useFormContext = w, exports.useFormState = T, exports.useWatch = N;
  }
});

// node_modules/@hookform/resolvers/dist/resolvers.js
var require_resolvers = __commonJS({
  "node_modules/@hookform/resolvers/dist/resolvers.js"(exports) {
    var r = require_index_cjs();
    var e = function(e2, i2, t) {
      if (e2 && "reportValidity" in e2) {
        var a = r.get(t, i2);
        e2.setCustomValidity(a && a.message || ""), e2.reportValidity();
      }
    };
    var i = function(r2, i2) {
      var t = function(t2) {
        var a2 = i2.fields[t2];
        a2 && a2.ref && "reportValidity" in a2.ref ? e(a2.ref, t2, r2) : a2.refs && a2.refs.forEach(function(i3) {
          return e(i3, t2, r2);
        });
      };
      for (var a in i2.fields)
        t(a);
    };
    exports.toNestError = function(e2, t) {
      t.shouldUseNativeValidation && i(e2, t);
      var a = {};
      for (var o in e2) {
        var f = r.get(t.fields, o);
        r.set(a, o, Object.assign(e2[o], { ref: f && f.ref }));
      }
      return a;
    }, exports.validateFieldsNatively = i;
  }
});

// node_modules/@hookform/resolvers/zod/dist/zod.js
var require_zod = __commonJS({
  "node_modules/@hookform/resolvers/zod/dist/zod.js"(exports) {
    var r = require_index_cjs();
    var e = require_resolvers();
    var o = function(e2, o2) {
      for (var s = {}; e2.length; ) {
        var n = e2[0], t = n.code, i = n.message, a = n.path.join(".");
        if (!s[a])
          if ("unionErrors" in n) {
            var u = n.unionErrors[0].errors[0];
            s[a] = { message: u.message, type: u.code };
          } else
            s[a] = { message: i, type: t };
        if ("unionErrors" in n && n.unionErrors.forEach(function(r2) {
          return r2.errors.forEach(function(r3) {
            return e2.push(r3);
          });
        }), o2) {
          var c = s[a].types, l = c && c[n.code];
          s[a] = r.appendErrors(a, o2, s, t, l ? [].concat(l, n.message) : n.message);
        }
        e2.shift();
      }
      return s;
    };
    exports.zodResolver = function(r2, s, n) {
      return void 0 === n && (n = {}), function(t, i, a) {
        try {
          return Promise.resolve(function(o2, i2) {
            try {
              var u = Promise.resolve(r2["sync" === n.mode ? "parse" : "parseAsync"](t, s)).then(function(r3) {
                return a.shouldUseNativeValidation && e.validateFieldsNatively({}, a), { errors: {}, values: n.rawValues ? t : r3 };
              });
            } catch (r3) {
              return i2(r3);
            }
            return u && u.then ? u.then(void 0, i2) : u;
          }(0, function(r3) {
            return { values: {}, errors: r3.isEmpty ? {} : e.toNestError(o(r3.errors, !a.shouldUseNativeValidation && "all" === a.criteriaMode), a) };
          }));
        } catch (r3) {
          return Promise.reject(r3);
        }
      };
    };
  }
});
export default require_zod();
//# sourceMappingURL=@hookform_resolvers_zod_dist_zod__js.js.map
